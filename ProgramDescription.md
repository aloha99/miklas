Short Summary: Description of a computer game framework, which is used as an artificial life simulation.

# Introduction #

“Miklas” was developed from the computer game “Pacman”, which is based on JGameGrid. The Game Engine of JGameGrid shown in Fig. X is used to create a simple agent simulation framework, which is easily accessible for developers with little experience in programming. It allows rapid deployment and testing of cognitive architectures like “ARS” from the previous chapter. Compared to the original “Pacman” computer game, everything in the “world” is an agent, which can have interactions with other agents. Another feature was to make the game extremely configurable, in order to allow a user to easily set up a world with agents and interaction rules through configuration without much programming.

# Details #
The actors were provided by the game engine as agents. An actor consists of a Body and two interaction methods with other agents. The method first is that an actor, “Actor 1” can perform an action on “Actor 2”. If “actor 1” has performed an action on “Actor 2”, “Actor 2” performs the reaction on “Actor 1”. The body is defined through the events, which are assigned to it. An event is similar to the concept of a codelet in the cognitive architecture “ARS”. An independent piece of code is managed in a container structure and run, if certain conditions apply. An extension to the codelets in “ARS” is that a condition is also a codelet, which is always executed if called. Events are registered in an event handler (not visible in Fig. X). In case an action is performed on the Actor or as a reaction of an own action, the input data is tested on all registered events for that type (event (eff) of Fig. X). Any matching events are executed. This is the first part of the problem pattern on the body.
In addition to reaction on external stimuli, the actor itself does something in its environment every time execution is started. The Mind is started, in which any cognitive agent architecture can be placed. Through perception, a representation of other agents in a radius are provided. Together with homeostatic values from the body, the mind provides an action. Similar to events of effects, events are defined for each possible action (event (act) in Fig. X) of that body. The matching action is then executed in action on the agents of the target position. After the mind has been executed, the matching body internal events (event (int) in Fig. X) are executed. Here, the scalability of the problem is visible the first part of the problem pattern not only applies on external calls on the body, but also on two places within it. The solution inside the body looks like the solution if the Body were a black box. It shows some traits of self-similarity.
To get an idea of how the agent works, it is demonstrated in the following example: “Actor 1” executes the action “eat” on “Actor 2”, which is something eatable. “Actor 2” receives the action “eat” and the event (eff) “Being eaten” is executed. This event is only an instanced configuration of the event “Set Health”. “Being eaten” sets the health in the body to 0. The reaction on “Actor 1” of the action “eat” on “Actor 2” is the event “Eat Good”, which also is an instanced configuration of the event “Set health” but this time with a positive health. As it is the turn of “Actor 2”, the internal event “Death” is executed in event (int).
The main advantage by defining the body through events is that the classes of events and conditions only consists of small, individual pieces of code. Customized bodies and interactions can be created at runtime from a limited number of programmed classes for events. Compared to the previous examples, this is an extended version of the “ARS” functionality, with an explicit mind, which represents the second part of the problem pattern.